package distributed

import (
	"fmt"
	"time"
)

// Узел
type Node struct {
	ID         int
	alive      bool
	Inbox      chan Message
	leaderID   int
	startBully bool
	// Для Bully: no big container, just slice of other nodeIDs
	NextID int // Для Ring: nextID int (кольцо)
	// Для Raft: term, state, log ...
}

// Сообщение
type Message struct {
	From    int
	To      int
	Content string
}

// Диспетчер
type Dispatcher struct {
	nodes map[int]chan Message // Карта: ID узла -> Канал узла
}

// ============================

// Создание нового диспетчера
func NewDispatcher() *Dispatcher {
	return &Dispatcher{
		nodes: make(map[int]chan Message),
	}
}

// Регистрация узла в диспетчере
func (d *Dispatcher) RegisterNode(nodeID int, inbox chan Message) {
	d.nodes[nodeID] = inbox
	//fmt.Println("Node", nodeID, "registered")
}

// Отправка сообщения от одного узла к другому
func (d *Dispatcher) Send(from, to int, content string) {
	d.nodes[to] <- Message{
		From:    from,
		To:      to,
		Content: content,
	}
}

func (d *Dispatcher) SendToAll(from int, content string) {
	for to, inbox := range d.nodes {
		if to != from {
			inbox <- Message{
				From:    from,
				To:      to,
				Content: content,
			}
		}
	}
}

func (d *Dispatcher) SendHight(from int, content string) {
	for to, inbox := range d.nodes {
		if to > from {
			inbox <- Message{
				From:    from,
				To:      to,
				Content: content,
			}
		}
	}
}

// ============================

// Проверка жив ли узел
func (n *Node) IsAlive() bool {
	return n.alive
}

func (n *Node) SetAlive(alive bool) {
	n.alive = alive
}

func (n *Node) GetLeaderID() int {
	return n.leaderID
}

func (n *Node) SetLeaderID(leaderID int) {
	n.leaderID = leaderID
}

/*
var mutex sync.Mutex

// Метод узла для обработки сообщений
func (n *Node) Start(d *Dispatcher) {
	n.alive = true
	for msg := range n.Inbox {
		if n.alive {
			fmt.Printf("Node %d received message from %d: %s\n", n.ID, msg.From, msg.Content)
			n.Bully(msg, d)
		}
		if n.startBully {
			if msg.Content == "OK" {
				n.startBully = false
			}
		}

	}
}

func (n *Node) Bully(msg Message, d *Dispatcher) {
	time.Sleep(100 * time.Millisecond)
	if msg.Content == "ELECTION" {
		if n.ID > msg.From {
			d.Send(n.ID, msg.From, "OK")
			time.Sleep(200 * time.Millisecond)
			n.StartBully(d)
		}
	} else if msg.Content == "COORDINATOR" {
		n.SetLeaderID(msg.From)
	} else if msg.Content == "OK" {
		n.startBully = false
	} else if n.startBully {
		select {
		case <-time.After(2 * time.Second):
			fmt.Printf("--> Node %d: I'm the boss\n", n.ID)
			d.SendToAll(n.ID, "COORDINATOR")
			n.SetLeaderID(n.ID)
			n.startBully = false
		}
	}
}

func (n *Node) StartBully(d *Dispatcher) {
	d.SendHight(n.ID, "ELECTION")
	n.startBully = true

	time.Sleep(1200 * time.Millisecond)

	mutex.Lock()
	select {
	case msg := <-n.Inbox:
		fmt.Println("12312321", n.ID)
		if msg.Content == "OK" {
			n.startBully = false
			return
		}
	case <-time.After(2 * time.Second):
		if n.startBully {
			fmt.Printf("--> Node %d: I'm the boss\n", n.ID)
			d.SendToAll(n.ID, "COORDINATOR")
			n.SetLeaderID(n.ID)
			n.startBully = false
		}
	}
	mutex.Unlock()
	time.Sleep(1 * time.Second)
}
*/

func (n *Node) Bully(d *Dispatcher) {
	n.alive = true
	for msg := range n.Inbox {
		if !n.alive {
			return
		}
		fmt.Printf("Node %d received message from %d: %s\n", n.ID, msg.From, msg.Content)

		switch msg.Content {
		case "ELECTION":
			if n.ID > msg.From {
				d.Send(n.ID, msg.From, "OK")
				time.Sleep(100 * time.Millisecond)
				n.StartBully(d)
			}
		case "COORDINATOR":
			if msg.From > n.leaderID {
				n.SetLeaderID(msg.From)
				n.startBully = false // Остановим дальнейшие выборы
			}
		case "OK":
			// Если получили "OK", продолжаем ждать
			n.startBully = false
		}
	}
}

func (n *Node) StartBully(d *Dispatcher) {
	n.startBully = true
	d.Send(n.ID, n.ID, "startBully")
	d.SendHight(n.ID, "ELECTION")

	time.Sleep(500 * time.Millisecond)

	select {
	case msg := <-n.Inbox:
		if msg.Content == "OK" {
			n.startBully = false
			n.Bully(d)
			return
		}
	default:
		// Продолжаем выполнять проверку, если нет входящего сообщения
	}

	// Если спустя 2 секунды не было ответа, считаем себя координатором
	if n.startBully {
		fmt.Printf("--> Node %d: I'm the boss\n", n.ID)
		d.SendToAll(n.ID, "COORDINATOR")
		n.SetLeaderID(n.ID)
		n.startBully = false
	}

	time.Sleep(1 * time.Second)
}
